import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import Config
from Simulation import PairTradingStrategy

# to run: streamlit run Dashboard.py
st.set_page_config(layout="wide", page_title="Pairs Trading Dashboard")

def load_simulation_results():
    """
    Loads the summary CSV file generated by MultiSimulationOneProcess.py.
    """
    file_path = Config.PROCESSED_DIR / "simulation_results.csv"
    if file_path.exists():
        return pd.read_csv(file_path)
    return pd.DataFrame()

def load_market_data():
    """
    Loads the parquet file with market data.
    """
    if Config.PROCESSED_MARKET_DATA.exists():
        return pd.read_parquet(Config.PROCESSED_MARKET_DATA)
    return pd.DataFrame()

def plot_pair_analysis(strategy):
    """
    Generates interactive plots:
    Row 1: Prices (Left Axis) + Equity Curve (Right Axis) overlaid.
    Row 2: Z-Score and signals.
    """
    df = strategy.df
    
    # 1. Identify the performance column
    perf_col = None
    if 'cum_return' in df.columns:
        perf_col = 'cum_return'
    elif 'strategy_return' in df.columns:
        df['cum_return'] = (1 + df['strategy_return'].fillna(0)).cumprod()
        perf_col = 'cum_return'
    
    # 2. Configure Layout: 2 rows
    fig = make_subplots(
        rows=2, cols=1, 
        shared_xaxes=True, 
        vertical_spacing=0.1,
        subplot_titles=(f"Price history & Strategy Performance", "Z-Score & Trading Signals"),
        row_heights=[0.6, 0.4],
        specs=[[{"secondary_y": True}], [{"secondary_y": False}]]
    )

    # --- ROW 1: Prices ---
    fig.add_trace(go.Scatter(x=df.index, y=df[strategy.ticker1], name=f"{strategy.ticker1} (Price)", 
                             line=dict(color='blue', width=1), opacity=0.5), row=1, col=1, secondary_y=False)
    fig.add_trace(go.Scatter(x=df.index, y=df[strategy.ticker2], name=f"{strategy.ticker2} (Price)", 
                             line=dict(color='orange', width=1), opacity=0.5), row=1, col=1, secondary_y=False)

    # --- ROW 1: Equity Curve ---
    if perf_col:
        fig.add_trace(
            go.Scatter(
                x=df.index, 
                y=df[perf_col], 
                name='Strategy Equity', 
                line=dict(color='purple', width=3), 
            ), 
            row=1, col=1, secondary_y=True
        )

    # --- ROW 2: Z-Score ---
    fig.add_trace(go.Scatter(x=df.index, y=df['z_score'], name='Z-Score', line=dict(color='black', width=1)), row=2, col=1)
    
    # Threshold lines
    fig.add_hline(y=strategy.std_dev_entry, line_dash="dash", line_color="red", annotation_text="Short Entry", row=2, col=1)
    fig.add_hline(y=-strategy.std_dev_entry, line_dash="dash", line_color="green", annotation_text="Long Entry", row=2, col=1)
    fig.add_hline(y=0, line_color="gray", line_width=1, row=2, col=1)

    # Signals
    long_entries = df[df['signal'] == 1]
    fig.add_trace(go.Scatter(x=long_entries.index, y=long_entries['z_score'], 
                             mode='markers', marker=dict(color='green', size=8, symbol='triangle-up'),
                             name='Long Signal'), row=2, col=1)

    short_entries = df[df['signal'] == -1]
    fig.add_trace(go.Scatter(x=short_entries.index, y=short_entries['z_score'], 
                             mode='markers', marker=dict(color='red', size=8, symbol='triangle-down'),
                             name='Short Signal'), row=2, col=1)

    # Layout updates
    fig.update_layout(
        height=800, 
        title_text="Detailed Strategy Analysis",
        dragmode='pan',
        yaxis=dict(title=dict(text="Asset Prices", font=dict(color="blue"))),
        yaxis2=dict(title=dict(text="Strategy Equity", font=dict(color="purple")), overlaying="y", side="right"),
        xaxis=dict(rangeslider=dict(visible=False)),
        xaxis2=dict(rangeslider=dict(visible=True), type="date")
    )
    
    return fig

def main():
    st.title("Pairs Trading Simulation Dashboard")
    st.markdown("Analyze backtest results and visualize cointegrated pairs.")

    # 1. Sidebar: Configuration
    st.sidebar.header("Configuration")
    
    results_df = load_simulation_results()
    market_data = load_market_data()

    if results_df.empty:
        st.error("No simulation results found. Please run 'MultiSimulationOneProcess.py' first.")
        return

    if market_data.empty:
        st.error("No market data found. Please run 'LoadData.py' first.")
        return

    # 2. Results Overview Table
    st.header("Top Performing Pairs")
    
    if 'sharpe_ratio' in results_df.columns:
        min_sharpe = st.sidebar.slider("Minimum Sharpe Ratio", min_value=-2.0, max_value=5.0, value=0.0, step=0.1)
        filtered_results = results_df[results_df['sharpe_ratio'] >= min_sharpe]
    else:
        filtered_results = results_df
    
    format_dict = {}
    if 'total_return' in filtered_results.columns: format_dict['total_return'] = '{:.2%}'
    if 'sharpe_ratio' in filtered_results.columns: format_dict['sharpe_ratio'] = '{:.2f}'
    if 'final_value' in filtered_results.columns: format_dict['final_value'] = '{:.2f}'
    
    st.dataframe(filtered_results.style.format(format_dict))

    st.markdown("---")

    # ==========================================
    # 3. GLOBAL ANALYSIS: Cointegration vs Profit
    # ==========================================
    st.header("üìä Global Analysis: Cointegration vs Profit")
    
    numeric_cols = filtered_results.select_dtypes(include=['float', 'int', 'float64', 'int64']).columns.tolist()

    if len(numeric_cols) >= 2:
        c1, c2 = st.columns(2)
        with c1:
            default_ix_x = 0
            for i, col in enumerate(numeric_cols):
                if 'p_value' in col.lower() or 'score' in col.lower() or 'coint' in col.lower():
                    default_ix_x = i
                    break
            x_axis_col = st.selectbox("Select X-Axis (e.g. Cointegration P-Value)", numeric_cols, index=default_ix_x)

        with c2:
            default_ix_y = 1
            for i, col in enumerate(numeric_cols):
                if 'total_return' in col.lower() or 'profit' in col.lower() or 'sharpe' in col.lower():
                    default_ix_y = i
                    break
            if default_ix_y == default_ix_x and len(numeric_cols) > 1:
                 default_ix_y = (default_ix_x + 1) % len(numeric_cols)
            y_axis_col = st.selectbox("Select Y-Axis (e.g. Total Return)", numeric_cols, index=default_ix_y)

        # --- Y-AXIS VERTICAL SLIDER LOGIC ---
        y_min_val = float(filtered_results[y_axis_col].min())
        y_max_val = float(filtered_results[y_axis_col].max())
        buffer = (abs(y_max_val) + abs(y_min_val)) * 0.05
        
        st.markdown("**‚ÜïÔ∏è Vertical Zoom (Y-Axis Range):**")
        y_range = st.slider(
            f"Filter range for {y_axis_col}", 
            min_value=y_min_val - buffer, 
            max_value=y_max_val + buffer,
            value=(y_min_val - buffer, y_max_val + buffer),
            key="scatter_y_slider",
            label_visibility="collapsed"
        )

        fig_scatter = px.scatter(
            filtered_results,
            x=x_axis_col,
            y=y_axis_col,
            hover_data=filtered_results.columns,
            color=y_axis_col,
            color_continuous_scale='RdYlGn',
            title=f"{x_axis_col} vs {y_axis_col}",
            height=500,
            trendline="ols"
        )
        
        fig_scatter.update_xaxes(rangeslider_visible=True)
        fig_scatter.update_yaxes(range=y_range)

        if 'p_value' in x_axis_col.lower() or 'pvalue' in x_axis_col.lower():
             fig_scatter.add_vline(x=0.05, line_dash="dash", line_color="red", annotation_text="Significance (0.05)")

        st.plotly_chart(fig_scatter, use_container_width=True)
    else:
        st.warning("Not enough numeric data to generate scatter plot.")

    st.markdown("---")

    # 4. Detailed Pair Analysis
    st.header("Detailed Strategy View")
    
    if 'pair' in filtered_results.columns:
        pair_list = filtered_results['pair'].tolist()
        
        if not pair_list:
            st.warning("No pairs match filters.")
            return

        selected_pair = st.selectbox("Select Pair to Visualize", pair_list)
        
        if selected_pair:
            row = filtered_results[filtered_results['pair'] == selected_pair].iloc[0]
            
            t1 = row.get('ticker_1', selected_pair.split('-')[0])
            t2 = row.get('ticker_2', selected_pair.split('-')[1] if '-' in selected_pair else '')
            
            m1, m2, m3 = st.columns(3)
            if 'total_return' in row: m1.metric("Total Return", f"{row['total_return']:.2%}")
            if 'sharpe_ratio' in row: m2.metric("Sharpe Ratio", f"{row['sharpe_ratio']:.2f}")
            if 'final_value' in row: m3.metric("Final Value", f"{row['final_value']:.2f}")

            try:
                strategy = PairTradingStrategy(t1, t2, market_data)
                strategy.run_backtest() 
                
                fig = plot_pair_analysis(strategy)
                st.plotly_chart(fig, use_container_width=True)
                
                with st.expander("View Raw Data"):
                    st.dataframe(strategy.df.tail(100))
                    
            except KeyError as e:
                st.error(f"Error: One of the tickers ({t1}, {t2}) is missing from the market data file. ({e})")
            except Exception as e:
                st.error(f"An error occurred during strategy simulation: {e}")

    # ==========================================
    # 5. AVERAGE PERFORMANCE BAR CHART
    # ==========================================
    if 'sharpe_ratio' in filtered_results.columns and 'total_return' in filtered_results.columns:
        st.subheader("üìä Average Performance by Sharpe Quality")
        
        bins = [-float('inf'), 0.5, 1.5, float('inf')]
        labels = ['Weak (< 0.5)', 'Average (0.5 - 1.5)', 'Best (> 1.5)']
        
        df_cat = filtered_results.copy()
        df_cat['Quality'] = pd.cut(df_cat['sharpe_ratio'], bins=bins, labels=labels)
        
        stats = df_cat.groupby('Quality', observed=True).agg(
            avg_return=('total_return', 'mean'),
            count=('total_return', 'count')
        ).reset_index()
        
        total_pairs = len(filtered_results)
        if total_pairs > 0:
            stats['share'] = stats['count'] / total_pairs
        else:
            stats['share'] = 0.0

        stats['label'] = stats.apply(
            lambda x: f"{x['avg_return']:.2%} (n={int(x['count'])}, {x['share']:.1%})", 
            axis=1
        )
        
        # --- Y-AXIS SLIDER LOGIC ---
        bar_y_min = float(stats['avg_return'].min())
        bar_y_max = float(stats['avg_return'].max())
        bar_buffer = (abs(bar_y_max) + abs(bar_y_min)) * 0.1 if bar_y_max != bar_y_min else 0.1

        st.markdown("**‚ÜïÔ∏è Vertical Zoom (Avg Return):**")
        bar_y_range = st.slider(
            "Filter Bar Chart Range",
            min_value=bar_y_min - bar_buffer,
            max_value=bar_y_max + bar_buffer,
            value=(bar_y_min - bar_buffer, bar_y_max + bar_buffer),
            key="bar_y_slider",
            label_visibility="collapsed"
        )

        fig_bar = px.bar(
            stats,
            x='Quality',
            y='avg_return',
            color='avg_return',
            title="Average Total Return per Sharpe Category",
            labels={'avg_return': 'Avg Total Return', 'Quality': 'Sharpe Ratio Category'},
            color_continuous_scale='RdYlGn',
            text='label',
            hover_data={'count': True, 'avg_return': ':.2%', 'label': False, 'share': ':.1%'}
        )
        
        fig_bar.update_xaxes(rangeslider_visible=True)
        fig_bar.update_yaxes(range=bar_y_range)
        
        fig_bar.update_traces(textposition='auto')
        fig_bar.update_layout(showlegend=False)
        st.plotly_chart(fig_bar, use_container_width=True)

    st.markdown("---")
    st.subheader("üìä Distribution of Returns (Rozk≈Çad Zysk√≥w)")

    if 'total_return' in filtered_results.columns:
        mean_ret = filtered_results['total_return'].mean()
        median_ret = filtered_results['total_return'].median()
        max_ret = filtered_results['total_return'].max()
        min_ret = filtered_results['total_return'].min()

        c1, c2, c3, c4 = st.columns(4)
        c1.metric("Mean Return", f"{mean_ret:.2%}")
        c2.metric("Median Return", f"{median_ret:.2%}")
        c3.metric("Max Return", f"{max_ret:.2%}")
        c4.metric("Min Return", f"{min_ret:.2%}", delta_color="inverse")

        fig_hist = px.histogram(
            filtered_results,
            x="total_return",
            nbins=100, 
            title="Histogram: Strategy Return Distribution",
            labels={'total_return': 'Total Return'},
            color_discrete_sequence=['#636EFA'],
            hover_data=filtered_results.columns
        )

        fig_hist.update_xaxes(rangeslider_visible=True)

        fig_hist.add_vline(x=0, line_dash="dash", line_color="white", annotation_text="Break Even (0%)")
        fig_hist.add_vline(x=mean_ret, line_dash="dot", line_color="yellow", annotation_text="Mean")

        fig_hist.update_layout(
            xaxis_tickformat='.0%',
            bargap=0.1
        )

        st.plotly_chart(fig_hist, use_container_width=True)

    # ==========================================
    # 6. NEW CHART: Performance Distribution (Sorted Line)
    # ==========================================
    st.markdown("---")
    st.subheader("üìà Performance Distribution Profile (Percentile vs Profit)")
    st.markdown("Displays the profit distribution from worst to best pairs as a continuous curve.")

    # Allow user to choose Y-axis metric
    y_options = [c for c in ['total_return', 'final_value', 'sharpe_ratio'] if c in filtered_results.columns]
    y_col = st.selectbox("Select Profit Metric (Y-Axis)", y_options, index=0)

    if y_col:
        # 1. Sort Data by the selected metric
        df_sorted = filtered_results.sort_values(by=y_col).reset_index(drop=True)
        
        # 2. Calculate Percentile (0.0 to 1.0)
        # We assign a rank percentile to each pair
        df_sorted['percentile'] = (df_sorted.index / (len(df_sorted) - 1))
        
        # 3. Sliders for Vertical Zoom
        y_min_line = float(df_sorted[y_col].min())
        y_max_line = float(df_sorted[y_col].max())
        y_buff_line = (abs(y_max_line) + abs(y_min_line)) * 0.05

        st.markdown(f"**‚ÜïÔ∏è Vertical Zoom ({y_col}):**")
        line_y_range = st.slider(
            "Filter Line Chart Range",
            min_value=y_min_line - y_buff_line,
            max_value=y_max_line + y_buff_line,
            value=(y_min_line - y_buff_line, y_max_line + y_buff_line),
            key="line_y_slider",
            label_visibility="collapsed"
        )

        # 4. Plot Line Chart
        fig_line = px.line(
            df_sorted,
            x="percentile",
            y=y_col,
            hover_data=filtered_results.columns,
            title=f"Performance Curve: {y_col} by Percentile",
            labels={'percentile': 'Percentile (0% = Worst, 100% = Best)', y_col: y_col},
        )
        
        # Style as a smooth line area if desired, or just line
        fig_line.update_traces(line=dict(color='cyan', width=2))
        
        # Horizontal slider (rangeslider) + Format X as %
        fig_line.update_xaxes(rangeslider_visible=True, tickformat='.0%')
        # Vertical slider application
        fig_line.update_yaxes(range=line_y_range)

        st.plotly_chart(fig_line, use_container_width=True)
    else:
        st.warning("Data for plotting is missing.")

if __name__ == "__main__":
    main()